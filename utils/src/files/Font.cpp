#include <cstdlib>
#include <cstring>
#include <cmath>

#ifdef DEBUG
#include <cstdio>
#endif

#include <ft2build.h>
#include FT_FREETYPE_H
#include FT_GLYPH_H
#include FT_OUTLINE_H
#include FT_BITMAP_H
#include FT_STROKER_H

#include "files/Image.hpp"
#include "files/Font.hpp"
#include "opengl/holder/GlResourceHolder.hpp"

namespace
{
    // Helper to intepret memory as a specific type
    template <typename T, typename U>
    inline T reinterpret(const U& input) noexcept
    {
        T output;
        memcpy(&output, &input, sizeof(U));

        return output;
    }

    // Combine outline thickness, boldness and font glyph index into a single 64-bit key
    uint64_t combine(float outlineThickness, bool bold, uint32_t index) noexcept
    {
        return (static_cast<uint64_t>(reinterpret<uint32_t>(outlineThickness)) << 32) | (static_cast<uint64_t>(bold) << 31) | index;
    }
}


Row::Row(uint32_t rowTop, uint32_t rowHeight) noexcept: 
    width(0), 
    top(rowTop), 
    height(rowHeight) 
{

}


Font::Font(GlResourceHolder& holder) noexcept:
    m_glResources(holder),
    m_library  (nullptr),
    m_face     (nullptr),
    m_stroker  (nullptr),
    m_isSmooth (true),
    m_info()
{

}


Font::~Font() noexcept
{
    cleanup();
}


bool Font::loadFromFile(const std::filesystem::path& filepath) noexcept
{
    cleanup();

    if (FT_Library library; FT_Init_FreeType(&library) == 0) // Initialize FreeType
    {
        if (FT_Face face; FT_New_Face(library, filepath.generic_string().c_str(), 0, &face) == 0) // Load the new font face from the specified file
        {
            if (FT_Stroker stroker; FT_Stroker_New(library, &stroker) == 0) // Load the stroker that will be used to outline the font
            {
                if (FT_Select_Charmap(face, FT_ENCODING_UNICODE) == 0) // Select the unicode character map
                {
                    m_library = library;
                    m_stroker = stroker;
                    m_face = face;
                
                    if(face->family_name)
                        m_info.family = face->family_name;

                    return true;
                }
                else
                {
                    FT_Stroker_Done(stroker);
                    FT_Done_Face(face);
                }  
            }
            else
            {
                FT_Done_Face(face);
            }
        }
    }

    return false;
}


const Font::Info& Font::getInfo() const noexcept
{
    return m_info;
}


const Glyph& Font::getGlyph(uint32_t codePoint, uint32_t charSize, bool bold, float outlineThickness) const noexcept
{
    // Get the page corresponding to the character size
    auto& glyphs = loadPage(charSize).glyphs;

    // Build the key by combining the glyph index (based on code point), bold flag, and outline thickness
    uint64_t key = combine(outlineThickness, bold, FT_Get_Char_Index(static_cast<FT_Face>(m_face), codePoint));

    // Search the glyph into the cache
    if (auto it = glyphs.find(key); it != glyphs.end())
    {
        return it->second;
    }
    else
    {
        Glyph glyph = loadGlyph(codePoint, charSize, bold, outlineThickness);
        
        return glyphs.insert(std::make_pair(key, glyph)).first->second;
    }
}


bool Font::hasGlyph(uint32_t codePoint) const noexcept
{
    return FT_Get_Char_Index(static_cast<FT_Face>(m_face), codePoint) != 0;
}


float Font::getKerning(uint32_t first, uint32_t second, uint32_t charSize, bool bold) const noexcept
{
    // Special case where first or second is 0 (null character)
    if (first == 0 || second == 0)
        return 0.f;

    FT_Face face = static_cast<FT_Face>(m_face);

    if (face && setCurrentSize(charSize))
    {
        // Convert the characters to indices
        FT_UInt index1 = FT_Get_Char_Index(face, first);
        FT_UInt index2 = FT_Get_Char_Index(face, second);

        // Retrieve position compensation deltas generated by FT_LOAD_FORCE_AUTOHINT flag
        float firstRsbDelta = static_cast<float>(getGlyph(first, charSize, bold).rsbDelta);
        float secondLsbDelta = static_cast<float>(getGlyph(second, charSize, bold).lsbDelta);

        // Get the kerning vector if present
        FT_Vector kerning;
        kerning.x = kerning.y = 0;
        if (FT_HAS_KERNING(face))
            FT_Get_Kerning(face, index1, index2, FT_KERNING_UNFITTED, &kerning);

        // X advance is already in pixels for bitmap fonts
        if (!FT_IS_SCALABLE(face))
            return static_cast<float>(kerning.x);

        // Combine kerning with compensation deltas and return the X advance
        // Flooring is required as we use FT_KERNING_UNFITTED flag which is not quantized in 64 based grid
        return std::floor((secondLsbDelta - firstRsbDelta + static_cast<float>(kerning.x) + 32) / static_cast<float>(1 << 6));
    }
    else
    {
        // Invalid font
        return 0.f;
    }
}


float Font::getLineSpacing(uint32_t charSize) const noexcept
{
    FT_Face face = static_cast<FT_Face>(m_face);

    if (face && setCurrentSize(charSize))
        return static_cast<float>(face->size->metrics.height) / static_cast<float>(1 << 6);
    else
        return 0.f;
}


float Font::getUnderlinePosition(uint32_t charSize) const noexcept
{
    FT_Face face = static_cast<FT_Face>(m_face);

    if (face && setCurrentSize(charSize))
    {
        // Return a fixed position if font is a bitmap font
        if (!FT_IS_SCALABLE(face))
            return static_cast<float>(charSize) / 10.f;

        return -static_cast<float>(FT_MulFix(face->underline_position, face->size->metrics.y_scale)) / static_cast<float>(1 << 6);
    }
    else
    {
        return 0.f;
    }
}


float Font::getUnderlineThickness(uint32_t charSize) const noexcept
{
    FT_Face face = static_cast<FT_Face>(m_face);

    if (face && setCurrentSize(charSize))
    {
        // Return a fixed thickness if font is a bitmap font
        if (!FT_IS_SCALABLE(face))
            return static_cast<float>(charSize) / 14.f;

        return static_cast<float>(FT_MulFix(face->underline_thickness, face->size->metrics.y_scale)) / static_cast<float>(1 << 6);
    }
    else
    {
        return 0.f;
    }
}


const Texture2D* Font::getTexture(uint32_t charSize) const noexcept
{
    return loadPage(charSize).texture.get();
}


void Font::setSmooth(bool smooth) noexcept
{
    if (smooth != m_isSmooth)
    {
        m_isSmooth = smooth;

        for (auto& [id, page] : m_pages)
            page.texture->setSmooth(m_isSmooth);
    }
}


bool Font::isSmooth() const noexcept
{
    return m_isSmooth;
}


void Font::cleanup() noexcept
{
    if (m_stroker)
        FT_Stroker_Done(static_cast<FT_Stroker>(m_stroker));

    if (m_face)
        FT_Done_Face(static_cast<FT_Face>(m_face));

    if (m_library)
        FT_Done_FreeType(static_cast<FT_Library>(m_library));

    m_library = nullptr;
    m_face    = nullptr;
    m_stroker = nullptr;
    m_pages.clear();
}


Page& Font::loadPage(uint32_t charSize) const noexcept
{
    auto page = m_pages.find(charSize);

    if (page == m_pages.end())
    {
        auto handle = m_glResources.create<Texture2D, 1>();
        page = m_pages.insert(std::make_pair(charSize, Page(handle[0], m_isSmooth))).first;
    }

    return page->second;
}


Glyph Font::loadGlyph(uint32_t codePoint, uint32_t charSize, bool bold, float outlineThickness) const noexcept
{
    Glyph glyph;
    FT_Face face = static_cast<FT_Face>(m_face);

    // Set the character size
    if (!setCurrentSize(charSize))
        return glyph;

    // Load the glyph corresponding to the code point
    FT_Int32 flags = FT_LOAD_TARGET_NORMAL | FT_LOAD_FORCE_AUTOHINT;

    if (outlineThickness != 0)
        flags |= FT_LOAD_NO_BITMAP;

    if (FT_Load_Char(face, codePoint, flags) != 0)
        return glyph;

    // Retrieve the glyph
    FT_Glyph glyphDesc;
    if (FT_Get_Glyph(face->glyph, &glyphDesc) != 0)
        return glyph;

    // Apply bold and outline (there is no fallback for outline) if necessary -- first technique using outline (highest quality)
    FT_Pos weight = 1 << 6;
    bool outline = (glyphDesc->format == FT_GLYPH_FORMAT_OUTLINE);
    if (outline)
    {
        if (bold)
        {
            FT_OutlineGlyph outlineGlyph = reinterpret_cast<FT_OutlineGlyph>(glyphDesc);
            FT_Outline_Embolden(&outlineGlyph->outline, weight);
        }

        if (outlineThickness != 0)
        {
            FT_Stroker stroker = static_cast<FT_Stroker>(m_stroker);

            FT_Stroker_Set(stroker, static_cast<FT_Fixed>(outlineThickness * static_cast<float>(1 << 6)), FT_STROKER_LINECAP_ROUND, FT_STROKER_LINEJOIN_ROUND, 0);
            FT_Glyph_Stroke(&glyphDesc, stroker, true);
        }
    }

    // Convert the glyph to a bitmap (i.e. rasterize it)
    // Warning! After this line, do not read any data from glyphDesc directly, use
    // bitmapGlyph.root to access the FT_Glyph data.
    FT_Glyph_To_Bitmap(&glyphDesc, FT_RENDER_MODE_NORMAL, 0, 1);
    FT_BitmapGlyph bitmapGlyph = reinterpret_cast<FT_BitmapGlyph>(glyphDesc);
    FT_Bitmap& bitmap = bitmapGlyph->bitmap;

    // Apply bold if necessary -- fallback technique using bitmap (lower quality)
    if (!outline)
    {
        if (bold)
            FT_Bitmap_Embolden(static_cast<FT_Library>(m_library), &bitmap, weight, weight);
#ifdef DEBUG
        if (outlineThickness != 0)
            printf("Failed to outline glyph (no fallback available)\n");
#endif
    }

    // Compute the glyph's advance offset
    glyph.advance = static_cast<float>(bitmapGlyph->root.advance.x >> 16);

    if (bold)
        glyph.advance += static_cast<float>(weight) / static_cast<float>(1 << 6);

    glyph.lsbDelta = static_cast<int>(face->glyph->lsb_delta);
    glyph.rsbDelta = static_cast<int>(face->glyph->rsb_delta);

    uint32_t width  = bitmap.width;
    uint32_t height = bitmap.rows;

    if ((width > 0) && (height > 0))
    {
        // Leave a small padding around characters, so that filtering doesn't
        // pollute them with pixels from neighbors
        const uint32_t padding = 2;

        width  += (padding << 1);
        height += (padding << 1);

        // Get the glyphs page corresponding to the character size
        Page& page = loadPage(charSize);

        // Find a good position for the new glyph into the texture
        glyph.textureRect = findGlyphRect(page, width, height);

        // Make sure the texture data is positioned in the center
        // of the allocated texture rectangle
        glyph.textureRect.x += static_cast<int32_t>(padding);
        glyph.textureRect.y += static_cast<int32_t>(padding);
        glyph.textureRect.z -= static_cast<int32_t>(padding << 1);
        glyph.textureRect.w -= static_cast<int32_t>(padding << 1);

        // Compute the glyph's bounding box
        glyph.bounds.x = static_cast<float>( bitmapGlyph->left);
        glyph.bounds.y = static_cast<float>(-bitmapGlyph->top);
        glyph.bounds.z = static_cast<float>( bitmap.width);
        glyph.bounds.w = static_cast<float>( bitmap.rows);

        // Add the pixel buffer to the new size and fill it with transparent white pixels
        std::vector<uint8_t> pixelBuffer;
        pixelBuffer.resize(width * height * 4);

        uint8_t* current = pixelBuffer.data();
        uint8_t* end = current + width * height * 4;

        while (current != end)
        {
            (*current++) = 255;
            (*current++) = 255;
            (*current++) = 255;
            (*current++) = 0;
        }

        // Extract the glyph's pixels from the bitmap
        const uint8_t* pixels = bitmap.buffer;

        if(bitmap.pixel_mode == FT_PIXEL_MODE_MONO) // Pixels are 1 bit monochrome values
        {
            for (uint32_t y = padding; y < height - padding; ++y)
            {
                for (uint32_t x = padding; x < width - padding; ++x)
                {
                    // The color channels remain white, just fill the alpha channel
                    size_t index = y * width + x;
                    pixelBuffer[index * 4 + 3] = ((pixels[(x - padding) / 8]) & (1 << (7 - ((x - padding) % 8)))) ? 255 : 0;
                }

                pixels += bitmap.pitch;
            }
        }
        else // Pixels are 8 bits gray levels
        {
            for (uint32_t y = padding; y < height - padding; ++y)
            {
                for (uint32_t x = padding; x < width - padding; ++x)
                {
                    // The color channels remain white, just fill the alpha channel
                    size_t index = y * width + x;
                    pixelBuffer[index * 4 + 3] = pixels[x - padding];
                }

                pixels += bitmap.pitch;
            }
        }

        // Write the pixels to the texture
        uint32_t x = static_cast<uint32_t>(glyph.textureRect.x) - padding;
        uint32_t y = static_cast<uint32_t>(glyph.textureRect.y) - padding;
        uint32_t w = static_cast<uint32_t>(glyph.textureRect.z) + (padding << 1);
        uint32_t h = static_cast<uint32_t>(glyph.textureRect.w) + (padding << 1);
        page.texture->update(x, y, w, h, pixelBuffer.data());
    }

    FT_Done_Glyph(glyphDesc);

    return glyph;
}


glm::ivec4 Font::findGlyphRect(Page& page, uint32_t width, uint32_t height) const noexcept
{
    // Find the line that fits well the glyph
    Row* row = nullptr;
    float bestRatio = 0;

    for (auto it = page.rows.begin(); it != page.rows.end() && !row; ++it)
    {
        float ratio = static_cast<float>(height) / static_cast<float>(it->height);

        // Ignore rows that are either too small or too high
        if ((ratio < 0.7f) || (ratio > 1.f))
            continue;

        // Check if there's enough horizontal space left in the row
        if (width > page.texture->getWidth() - it->width)
            continue;

        // Make sure that this new row is the best found so far
        if (ratio < bestRatio)
            continue;

        // The current row passed all the tests: we can select it
        row = &*it;
        bestRatio = ratio;
    }

    // If we didn't find a matching row, create a new one (10% taller than the glyph)
    if (!row)
    {
        uint32_t rowHeight = height + height / 10;
        
        while ((page.nextRow + rowHeight >= page.texture->getHeight()) || (width >= page.texture->getWidth()))
        {
            // Not enough space: resize the texture if possible
            uint32_t textureWidth  = page.texture->getWidth() * 2;
            uint32_t textureHeight = page.texture->getHeight() * 2;

            if ((textureWidth <= Texture2D::getMaximumSize()) && (textureHeight <= Texture2D::getMaximumSize()))
            {
                // Make the texture 2 times bigger
                auto handle = m_glResources.create<Texture2D, 1>();
                auto newTexture = std::make_unique<Texture2D>(handle[0]);
                newTexture->create(textureWidth, textureHeight);
                newTexture->setSmooth(m_isSmooth);

                auto& oldTexture = page.texture;
                Image image;

                oldTexture->copyToImage(image);
                newTexture->update(0, 0, image.getSize().x, image.getSize().y, image.getPixelPtr());

                std::array<GLuint, 1> oldHandle = { oldTexture->getHandle() };
                m_glResources.destroy<Texture2D>(oldHandle);

                oldTexture.swap(newTexture);
            }
            else
            {
                // Oops, we've reached the maximum texture size...
                return glm::ivec4(0, 0, 2, 2);
            }
        }

        // We can now create the new row
        page.rows.push_back(Row(page.nextRow, rowHeight));
        page.nextRow += rowHeight;
        row = &page.rows.back();
    }

    // Find the glyph's rectangle on the selected row
    glm::ivec4 rect(glm::ivec4(row->width, row->top, width, height));

    // Update the row informations
    row->width += width;

    return rect;
}


bool Font::setCurrentSize(uint32_t charSize) const noexcept
{
    // FT_Set_Pixel_Sizes is an expensive function, so we must call it
    // only when necessary to avoid killing performances
    FT_Face face = static_cast<FT_Face>(m_face);
    FT_UShort currentSize = face->size->metrics.x_ppem;

    if (static_cast<uint32_t>(currentSize) != charSize)
    {
        FT_Error result = FT_Set_Pixel_Sizes(face, 0, charSize);
#ifdef DEBUG
        if (result == FT_Err_Invalid_Pixel_Size)
        {
            // In the case of bitmap fonts, resizing can
            // fail if the requested size is not available
            if (!FT_IS_SCALABLE(face))
            {

                printf("Failed to set bitmap font size to %u\n", charSize);
                printf("Available sizes are: ");

                for (FT_Int i = 0; i < face->num_fixed_sizes; ++i)
                {
                    const long size = (face->available_sizes[i].y_ppem + 32) >> 6;
                    printf("%u ", size);
                }

                printf("\n");
            }
            else printf("Failed to set font size to %u\n", charSize);
        }
#endif
        return result == FT_Err_Ok;
    }

    return true;
}


Page::Page(uint32_t handle, bool smooth) noexcept:
    nextRow(3)
{
    // Make sure that the texture is initialized by default
    Image image;
    image.create(128, 128, Color(255, 255, 255, 0));

    // Reserve a 2x2 white square for texturing underlines
    for (uint32_t x = 0; x < 2; ++x)
        for (uint32_t y = 0; y < 2; ++y)
            image.setPixel(x, y, Color(255, 255, 255, 255));

    // Create the texture
    texture = std::make_unique<Texture2D>(handle);
    texture->loadFromImage(image, false, true);
    texture->setSmooth(smooth);
}